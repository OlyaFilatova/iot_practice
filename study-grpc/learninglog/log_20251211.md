- gRPC
    - [x] https://grpc.io/blog/robotics/
        - Traditional ROS works well on trusted local networks but lacks internet communication support.
        - Some robot builders are also layering gRPC interfaces on top of ROS

        - Viam uses gRPC for orchestration and WebRTC for transport.

        - Why gRPC
            - Low-latency, real-time control via bidirectional streaming.
            - Cross-language, multi-platform
            - Efficient serialization
            - Built-in security
            - Service abstraction - each robot component becomes a standardized RPC service.

        - Why WebRTC
            - peer-to-peer connectivity especially when behind NAT/firewalls
            - bypassing central relays or cloud server
            - high-bandwidth streaming like video or LIDAR.
    - [x] https://grpc.io/blog/grpc-and-ai/
        - Encourages trying Gemini Code Assist for gRPC API development.
- Proto Buffers
    - [x] https://protobuf.dev/
        - Protocol Buffers - language-neutral, platform-neutral extensible mechanisms for serializing structured data.
        - define data structure once, then use generated source code to write and read structured data.
    - [x] https://protobuf.dev/history/
        - Protocol Buffers are described as an interchange format, not tied to any specific RPC protocol, unlike ASN.1, COM, CORBA, or Thrift.

    - [x] https://protobuf.dev/overview/
        - Protocol Buffers include:
            - Definition language (`.proto` files)
            - Generated code
            - Language-specific runtime libraries
            - Serialization format
            - Serialized data
        - Problems that Protocol Buffers solve
            - Provide a serialization format for typed, structured data up to a few megabytes.
            - Suitable for both network traffic and long-term storage.
            - Allow extension with new information without invalidating existing data or requiring code updates.
                - old code can read new messages, ignoring added fields.
                - new code can read old messages with default values for missing fields.
        - Protocol buffers may not suit:
            - Data larger than a few megabytes.
            - Comparing messages for equality without parsing.
            - Need for special-purpose compression algorithms (JPEG, PNG, etc.)
            - large multi-dimensional arrays of floating point numbers.
            - Non-object-oriented languages.
            - Scenarios needing self-describing data without `.proto` definitions.
            - Environments requiring formally standardized formats.
        - How protocol buffers work:
            - define data in a `.proto` file
            - compile it to generate code
            - use that code to work with structured data
            - Generated code includes utility methods to retrieve, check, serialize, parse data, etc.  
        - Protocol Buffers Definition Syntax
            - can specify field's cardinality: singular or repeated; make it optional. 
            - specify a data type. Supported kinds include:
                - primitive scalar types (e.g., integers, booleans, floats) 
                - message types (nested definitions) 
                - enum types (set of values) 
                - oneof types (only one field set at a time) 
                - map types (key-value pairs) 
            - field names have syntax rules; pluralize repeated fields.
            - it can be impossible, to change field names after they've been used in production.
            - After naming, assign a field number - these cannot be repurposed once used, and deleted ones should be reserved. 
        - Additional Data Type Support
            - Protocol Buffers support many scalar value types, including integers with both variable-length encoding and fixed sizes. 
            - Create composite data types by defining messages that act as types assignable to fields. 
            - Several common types (predefined message types) are published for reuse. 
