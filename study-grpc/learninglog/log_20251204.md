### gRPC
- [x] https://grpc.io/about/
- [x] https://grpc.io/docs/
- [x] https://grpc.io/docs/protoc-installation/
- [x] https://grpc.io/docs/what-is-grpc/introduction/
- [x] https://grpc.io/docs/what-is-grpc/core-concepts/
    - gRPC supports four kinds of RPC methods:
        - Unary RPCs
            `rpc SayHello(HelloRequest) returns (HelloResponse);`
            - client sends one request(metadata, method name, [deadline]), server sends initial metadata, server returns response (if successful) with status [+ trailing metadata]
        - Server-streaming RPCs
            `rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);`
            - after client request, server sends initial metadata, then a stream of messages; when done, server sends status [+ trailing metadata]
            - client finishes when all messages and status arrive
            - gRPC guarantees message ordering within the stream
        - Client-streaming RPCs
            `rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);`
            - client sends a stream of messages to server
            - server returns a single response, [+ trailing metadata]
            - gRPC guarantees message ordering within the stream
        - Bidirectional-streaming RPCs
            `rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);`
            - the call is initiated by the client invoking the method and the server receiving the client metadata, method name [+ deadline]. The server can choose to send back its initial metadata or wait for the client to start streaming messages
            - both client and server exchange streams of messages independently (read/write streams); each side can read and write in any order
            - Message ordering is preserved within each stream
    - Deadlines / Timeouts
        - Client can specify timeouts/deadlines for RPCs
        - if RPC takes longer, it fails with a DEADLINE_EXCEEDED error
        - On server side it's possible to check deadline or time left
        - Behavior (timeouts vs deadlines) is per-language API.
    - RPC termination & cancellation
        - Either client or server can cancel an RPC at any time
        - Cancellation terminates the RPC immediately
        - Any partial work before cancellation is not automatically rolled back. 
    - Metadata
        - RPC calls can carry metadata — a set of key-value pairs associated with the call (e.g. for authentication, routing, custom info).
        - Keys
            - case-insensitive ASCII strings, digits, special characters
            - must not start with `grpc`
            - Binary-valued keys end in `-bin` while ASCII-valued keys do not
        - values may be binary or string
        - Metadata handling is language-dependent.
    - Channels: A “channel” represents a connection to a gRPC server (host + port), used by clients to create stubs. 
        - Channels have state (e.g. connected, idle).
        - Clients can specify channel arguments (e.g. message compression on/off)
        - How channels are closed or queried depends on the language implementation
        - Some languages permit querying channel state
- [x] https://grpc.io/docs/what-is-grpc/faq/
    - gRPC is a fit for:
        - Low latency, highly scalable, distributed systems.
        - Communication between mobile clients and cloud servers (or other cross-device/server setups).
        - A new protocol that needs to be efficient, accurate, and language-independent.
        - A layered design that enables extension with features such as authentication, load balancing, logging, and monitoring.
    - The project follows a rolling-release model
        - gRPC does not issue long-term support (LTS) releases. Typically the two most recent releases are supported (current + previous).
        - Release frequency: gRPC aims to publish “checkpoint” releases about every 6 weeks (on a best-effort basis)
        - road map repo https://github.com/grpc/proposal
        - gRPC is designed to be extensible to support multiple content types (JSON, Protobuf, Thrift, FlatBuffers, XML)
    - there is a separate project gRPC‑Web (i.e. gRPC-Web) to enable using gRPC from browsers
    - xDS APIs enables deploying gRPC applications in a service mesh without sidecar proxies
    - proxyless service mesh features supported in gRPC [link](https://github.com/grpc/grpc/blob/master/doc/grpc_xds_features.md)
- [x] Read python docs
    - [x] https://grpc.io/docs/languages/python/
    - [x] https://grpc.io/docs/languages/python/quickstart/
        
        repo with examples https://github.com/grpc/grpc
        - dependencies
            - Runtime: `pip install grpcio`
            - compiler `pip install grpcio-tools`
        - running project
            - `cd examples/python/helloworld`
            - `python greeter_server.py`
            - `python greeter_client.py`
        - to compile after proto edit from `helloworld` folder run `python -m grpc_tools.protoc -I../../protos --python_out=. --pyi_out=. --grpc_python_out=. ../../protos/helloworld.proto`
            - note that if you want to run command from another folder there are 5 paths to edit
        - *_pb2.py file defines Python classes for request/response messages
        - *_pb2_grpc.py file defines Python classes (“stubs” and server skeletons) for the gRPC service
        - [x] Run example project
        - [x] Edit and run example project
        - [x] Create exceptions in the project and run
            - Client: 
                - For now I do not see an easy way to extract the custom exception info that was not caught on server. Exception class name is not available, params are described in a tuple in a string together with other text.
                - When server is down the code is StatusCode.UNAVAILABLE
            - Server
                - Error that was not caught has helpful traceback
                - Server continues running despite having an uncaught exception
        - [x] Call server using postman
            - to call server using postman:
                - switch to gRPC
                - import .proto file
                - choose function
                - in the message tab in json format describe input params
        - [x] Update project_1 using learnt knowledge from the example code
            - [x] unary RPC example