- [gRPC on wiki](https://en.wikipedia.org/wiki/GRPC)

    gRPC is a remote procedure call (RPC) framework

    - Uses HTTP/2 for transport
    - Uses Protocol Buffers (protobuf) as its Interface Description Language (IDL) and serialization format
    - Key capabilities:
        - Authentication support (e.g. via TLS, token‑based).
        - Bidirectional streaming and flow control.
        - Both blocking (synchronous) and non‑blocking (asynchronous) bindings.
        - Generates client and server bindings for many languages
        - Support for cancellation and timeouts
    - Authentication
        - Transport Layer Security (TLS) and token-based authentication
        - Connection to Google services must use TLS
        - types of credentials
            - channel credentials
            - call credentials
        - token-based authorization
            - Server Interceptor
            - Client Interceptor

    - organizations and companies that use gRPC: Uber, Square, Netflix, IBM, CoreOS, Docker, CockroachDB, Arista Networks, Cisco, Juniper Networks, Spotify, Zalando, Dropbox, Google. 

    - Common usage scenarios:
        - microservices architectures
        - backend services
        - mobile / *web* / IoT clients communicating with servers
    - Tools for testing
        - Postman
        - ezy
        - Insomnia
        - Step CI
    - Alternatives
        - Cap'n Proto
        - Apache Thrift
        - Apache Avro
        - JSON-RPC
        - XML-RPC

- [RPC on wiki](https://en.wikipedia.org/wiki/Remote_procedure_call)

    RPC is a mechanism in distributed computing whereby a program causes a procedure (subroutine) to execute in a different address space (often on another computer on a network), yet the code is written as if the call is local.

    - the caller is "client" and the executing side is "server."

    - location transparency - calling procedures appears the same whether local or remote.

    - RPC is a form of inter‑process communication (IPC) - processes have different address spaces when on the same machine.

    - gRPC enhances the basic RPC model by using efficient binary serialization (e.g., Protocol Buffers), HTTP/2 multiplexing, and built-in support for features such as authentication, load balancing, streaming, and error handling

    - RPC follows a request–response protocol: the client sends a request message to a server specifying which procedure to invoke + parameters; server executes it and returns a response.

    - While waiting for the response, the client is typically blocked - unless asynchronous RPC mechanisms are used.

    - Because remote calls depend on network communication, they can fail (e.g. due to network errors). The caller often cannot know whether the remote procedure was actually invoked.

    - For reliability, it’s easier if called procedures are idempotent (i.e. safe to execute more than once without harmful effects).

    - RPC Call Sequence (typical flow)
        1. Client calls a client stub.
        2. Client stub marshals the parameters: packs them into a message.
        3. Client OS sends the message over the network to the server machine.
        4. On server machine, OS delivers the message to a server stub.
        5. Server stub unmarshals the parameters
        6. Server calls the actual server procedure.
        7. The result is sent back along the reverse path
        8. The client continues as if the call were local.

    - The IDL files can then be used to generate code to interface between the client and servers.

- [Protocol Buffers on wiki](https://en.wikipedia.org/wiki/Protocol_Buffers)

    - Protocol Buffers is a serialization format, library, IDL compiler.
    - Protocol Buffers uses an interface description language (IDL)
        - data structure schemas (messages) and services are described in a `.proto` file
        - `protoc` generates source code
    - The generated code lets you convert between structured data (e.g. objects/records in your code) and a compact binary format and back.
    - Canonical serialization is into a binary wire format - compact, efficient.
    - The design goals of Protocol Buffers - small size and performance.
    - the serialized data does not include field names or type metadata; to interpret it properly the original schema (.proto file) must be used.
    - It can be used both for network communication (e.g. between services) and for storing data.
    - Protocol Buffers assume that the entire message can be loaded in memory
        - for large datasets (e.g. larger than a few megabytes), protobuf may not be a good fit.
    - The format does not provide built‑in compression.


## Further study options

- Read gRPC docs. Start with https://grpc.io/about/

- Start writing a gRPC project

- Read Protobuf docs https://protobuf.dev/

- Find what information there is on how exactly gRPC is used in the listed companies.

- Read research papers
