### gRPC
- [x] Read python docs (pt.2)
    - [x] https://grpc.io/docs/languages/python/basics/

        - [x] Read the page

            - command to generate gRPC client interfaces in a custom path("grpc/example/custom/path"):

                ```sh
                python -m grpc_tools.protoc -Igrpc/example/custom/path=../../protos --python_out=. --grpc_python_out=. ../../protos/route_guide.proto
                ```

            - Generated files explanation:

                    *_pb2.py - message classes

                    _pb2_grpc.py - Stub (client), Servicer base class (server), add_*_to_server helper

                    Note: "pb2" means protobuf Python API v2 (unrelated to `.proto` syntax version).
            ---

            ```python
            # server - subclass the generated Servicer
            class RouteGuideServicer(route_guide_pb2_grpc.RouteGuideServicer):
                def GetFeature(self, request, context):
                    ...
            ```

            - notes on starting server
                - start() method is non-blocking. A new thread will be instantiated to handle requests
                - you can call server.wait_for_termination() to block the calling thread until the server terminates

            ```python
            # client - Create stub to call service methods
            channel = grpc.insecure_channel('localhost:50051')
            stub = route_guide_pb2_grpc.RouteGuideStub(channel)
            ```

            ---
            #### Simple RPC
            ```proto
            rpc GetFeature(Point) returns (Feature) {}
            ```

            ```python
            # server sync
            def GetFeature(self, request, context):
                feature = get_feature(self.db, request)
                if feature is None:
                    return route_guide_pb2.Feature(name="", location=request)
                else:
                    return feature
            ```

            ```python
            # server async
            async def GetFeature(self, request, context):
                ...
            ```

            ```python
            # client sync
            stub.GetFeature(point)
            ```

            ```python
            # client async:
            await stub.GetFeature(point)
            ```

            #### Response-streaming
            ```proto
            rpc ListFeatures(Rectangle) returns (stream Feature) {}
            ```

            ```python
            # server sync

            def ListFeatures(self, request, context):
                left = min(request.lo.longitude, request.hi.longitude)
                right = max(request.lo.longitude, request.hi.longitude)
                top = max(request.lo.latitude, request.hi.latitude)
                bottom = min(request.lo.latitude, request.hi.latitude)
                for feature in self.db:
                    if (
                        feature.location.longitude >= left
                        and feature.location.longitude <= right
                        and feature.location.latitude >= bottom
                        and feature.location.latitude <= top
                    ):
                        yield feature
            ```

            ```python
            # server async

            async def ListFeatures(self, request, context):
                ...
            ```

            ```python
            # client sync
            for feature in stub.ListFeatures(rectangle):
                ...
            ```

            ```python
            # client async
            features = stub.ListFeatures(rectangle)

            async for feature in features:
                ...
            ```

            #### Request-streaming
            ```proto
            rpc RecordRoute(stream Point) returns (RouteSummary) {}
            ```

            ```python
            # server sync
            def RecordRoute(self, request_iterator, context):
                point_count = 0
                feature_count = 0
                distance = 0.0
                prev_point = None

                start_time = time.time()
                for point in request_iterator:
                    point_count += 1
                    if get_feature(self.db, point):
                        feature_count += 1
                    if prev_point:
                        distance += get_distance(prev_point, point)
                    prev_point = point

                elapsed_time = time.time() - start_time
                return route_guide_pb2.RouteSummary(
                    point_count=point_count,
                    feature_count=feature_count,
                    distance=int(distance),
                    elapsed_time=int(elapsed_time),
                )
            ```

            ```python
            # server async
            async def RecordRoute(self, request_iterator, context):
                ...
                async for point in request_iterator:
                    ...

                ...
            ```

            ```python
            # client async
            stub.RecordRoute(iterator_of_points)
            ```

            ```python
            # client async
            route_summary = await stub.RecordRoute(route_iterator)
            ```

            #### Bidirectional-streaming
            ```proto
            rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
            ```

            ```python
            # server sync
            def RouteChat(self, request_iterator, context):
                prev_notes = []
                for new_note in request_iterator:
                    for prev_note in prev_notes:
                        if prev_note.location == new_note.location:
                            yield prev_note
                    prev_notes.append(new_note)
            ```

            ```python
            # server async
            async def RouteChat(self, request_iterator, context):
                ...
                async for new_note in request_iterator:
                    ...
            ```

            ```python
            # client sync
            responses = stub.RouteChat(iterator_of_notes)
            for r in responses:
                ...
            ```

            ```python
            # client async
            call = stub.RouteChat(iterator_of_notes)
            async for response in call:
                ...
            ```

        - [x] Run python example

        - [x] Analyze python example

            **Example files are located at:**

            https://github.com/grpc/grpc/tree/master/examples/protos/route_guide.proto

            https://github.com/grpc/grpc/tree/master/examples/python/route_guide

            ---
            - starting async server
            ```python

            async def serve() -> None:
                server = grpc.aio.server()
                route_pb2_grpc.add_RouteServicer_to_server(
                    RouteServicer(), server
                )
                server.add_insecure_port("[::]:50051")
                await server.start()
                await server.wait_for_termination()


            if __name__ == "__main__":
                logging.basicConfig(level=logging.INFO)
                asyncio.get_event_loop().run_until_complete(serve())
            ```

            - starting sync server
                
                ```python
                def serve():
                    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
                    route_pb2_grpc.add_RouteServicer_to_server(
                        RouteServicer(), server
                    )
                    server.add_insecure_port("[::]:50051")
                    server.start()
                    server.wait_for_termination()


                if __name__ == "__main__":
                    logging.basicConfig()
                    serve()
                ```
            ---
            - running sync client
            ```python
            def run():
                with grpc.insecure_channel("localhost:50051") as channel:
                    stub = route_pb2_grpc.RouteStub(channel)
                    guide_get_feature(stub)
                    ...

            if __name__ == "__main__":
                logging.basicConfig()
                run()
            ```

            - running async client
            ```python
            async def main() -> None:
                async with grpc.aio.insecure_channel("localhost:50051") as channel:
                    stub = route_pb2_grpc.RouteStub(channel)
                    await guide_get_feature(stub)

            if __name__ == "__main__":
                logging.basicConfig()
                asyncio.get_event_loop().run_until_complete(main())
            ```
            ---

        - [x] Update project_1
            - [x] split python folder into server, client, grpc_python
                - [x] new generation command (from project_1 folder after venv activation)
                    ```sh
                    python -m grpc_tools.protoc -Idevice_controller/grpc_python=device_controller/protos --python_out=. --grpc_python_out=. device_controller/protos/device_controller.proto --pyi_out=.
                    ```
            - [x] create proto file(s) that have each of the new RPC types
                - [x] response streaming
                - [x] request streaming
                - [x] bidi streaming
                - [x] ensure to have comments
            - [x] implement new services
            - [x] update client
    - [x] https://grpc.io/docs/languages/python/generated-code/
        - the plain protoc generated code is stored in a _pb2.py file
        - the gRPC-specific code lands in a _pb2_grpc.py file and imports _pb2.py file
            - For each service Foo in the .proto file, three primary elements are generated:
                - Stub: FooStub
                    - used by the gRPC clients
                    - for connecting to a gRPC service
                    - constructor takes a grpc.Channel object
                - Servicer: FooServicer
                    - used by the server
                    - serves as the superclass of a gRPC service implementation
                    - service methods have corresponding functions the Servicer class
                    - comments associated with code elements in the .proto file appear as docstrings
                - Registration Function: add_FooServicer_to_server
                    - registers a Servicer object implementing it on a grpc.Server object
                    - allows the server to route queries to the respective servicer
        - (not listed on the page) _pb2.pyi file contains classes describing .proto messages
    - [x] https://grpc.io/docs/languages/python/alts/
        - Application Layer Transport Security (ALTS) is a mutual authentication and transport encryption system
        - ALTS is similar to mutual TLS but has been designed and optimized to meet the needs of Googleâ€™s production environments [link](https://docs.cloud.google.com/docs/security/encryption-in-transit/application-layer-transport-security)
        - ALTS in gRPC features
            - Create gRPC servers & clients with ALTS as the transport security protocol.
            - ALTS connections are end-to-end protected with privacy and integrity.
            - Applications can access peer information such as the peer service account.
            - Client authorization and server authorization support.
            - Minimal code changes to enable ALTS.
        - **Important limitation**: ALTS is fully supported only for connections between Google Cloud infrastructure and Google, **when the application runs on Google Compute Engine (GCE) or Google Kubernetes Engine (GKE)**.
        - ALTS does not support workload-to-workload authentication between **arbitrary GCP workloads** (i.e. using ALTS between general workloads is not supported).
            - ALTS does not work between those general-purpose workloads (like Cloud Run <-> Cloud Functions).
            - It only works in certain limited environments (GCE <-> GCE or GKE <-> GKE).
        - Client code
            ```python
            import grpc

            channel_creds = grpc.alts_channel_credentials()
            channel = grpc.secure_channel(address, channel_creds)
            ```
        - Server code
            ```python
            import grpc

            server = grpc.server(futures.ThreadPoolExecutor())
            server_creds = grpc.alts_server_credentials()
            server.add_secure_port(server_address, server_creds)
            ```
