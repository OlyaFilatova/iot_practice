- [x] https://grpc.io/docs/guides/auth/
    - provides authentication information as `Credentials` object.

    - Built-in auth options in gRPC include:
        - **SSL/TLS**
            - supports server authentication and encryption of data. 
            - clients can provide certificates for mutual TLS (client + server) authentication.
        - **ALTS**
            - a transport-security mechanism used when running on Google Compute Engine or Google Kubernetes Engine.
        - **Google token-based authentication**
            - gRPC can attach metadata-based credentials (e.g. OAuth2 tokens) to requests/responses.
            - Google-issued tokens should only be used to connect to Google services. Sending them to a non-Google service could risk credential theft and misuse.

    - gRPC defines two main credential types
        - **Channel credentials** - applied to an entire channel
        - **Call credentials** - applied per RPC call
    - can be combined using `composite_channel_credentials` - e.g. use SSL/TLS for the channel + per-call credentials for auth tokens.
    - multiple call-level credentials can be combined via `composite_call_credentials`.

    - **Client-side SSL/TLS**
        - create SSL channel credentials, then create a channel and stub to make RPC calls. 

    - **Token-based authentication (OAuth2 / metadata-based)** - typical flow:
        1. Client obtains or generates an OAuth token.
        2. Token is wrapped into Call credentials, which may be combined with channel credentials.
        3. Server receives the token (e.g. in HTTP Authorization header) and validates it (often via an interceptor).

    - **Google-specific credentials**
        - can be used when running on Google infrastructure or using service accounts

    - gRPC allows custom auth via the Credentials plugin API.
        - subclass `MetadataCredentialsPlugin` and implement its `GetMetadata` method.
        - create `CallCredentials` from this plugin using `MetadataCredentialsFromPlugin`.
        - This enables sending custom authentication headers (e.g. `"x-custom-auth-ticket": "super-secret-ticket"`) on RPC calls.
- [x] https://github.com/grpc/grpc/tree/master/examples/python/auth
    - TLS
        - server
            1. Create TLS credentials using grpc.ssl_server_credentials with certificate and certificate key - https://github.com/grpc/grpc/blob/master/examples/python/auth/tls_server.py#L43
            2. Protect with credentials using server.add_secure_port https://github.com/grpc/grpc/blob/master/examples/python/auth/tls_server.py#L53C5-L53C81
        - client
            1. Create credentials using grpc.ssl_channel_credentials with root certificate https://github.com/grpc/grpc/blob/master/examples/python/auth/tls_client.py#L45
            2. Create secure channel using grpc.secure_channel https://github.com/grpc/grpc/blob/master/examples/python/auth/tls_client.py#L48
    - Token based
        - server
            1. Implement grpc.ServerInterceptor
                - create _abort_handler method using grpc.unary_unary_rpc_method_handler https://github.com/grpc/grpc/blob/master/examples/python/auth/token_based_auth_server.py#L41
                - implement intercept_service method https://github.com/grpc/grpc/blob/master/examples/python/auth/token_based_auth_server.py#L43
                    - finds authentication header in handler_call_details.invocation_metadata
                    - verifies its value
                    - if OK - calls continuation else - aborts
            2. Add implementation to the list of server interceptors https://github.com/grpc/grpc/blob/master/examples/python/auth/token_based_auth_server.py#L65
            3. Add TLS credentials protection
        - client
            1. Create credentials using token and grpc.access_token_call_credentials https://github.com/grpc/grpc/blob/master/examples/python/auth/token_based_auth_client.py#L36C24-L36C58
            2. Create TLS credentials
            3. Compose together with TLS credential using grpc.composite_channel_credentials https://github.com/grpc/grpc/blob/master/examples/python/auth/token_based_auth_client.py#L44
            4. Create secure channel using grpc.secure_channel https://github.com/grpc/grpc/blob/master/examples/python/auth/token_based_auth_client.py#L48
    - Customized Auth
        - Sync
            - server
                1. implement grpc.ServerInterceptor
                    - create _abortion method using grpc.unary_unary_rpc_method_handler https://github.com/grpc/grpc/blob/master/examples/python/auth/customized_auth_server.py#L40
                    - implement intercept_service method https://github.com/grpc/grpc/blob/master/examples/python/auth/customized_auth_server.py#L42
                        - finds authentication header in handler_call_details.invocation_metadata
                        - verifies its value
                        - if OK - calls continuation else - aborts
                2. Add implementation to the list of server interceptors https://github.com/grpc/grpc/blob/master/examples/python/auth/customized_auth_server.py#L65
                3. Add TLS credentials protection
            - client
                1. implement grpc.AuthMetadataPlugin https://github.com/grpc/grpc/blob/master/examples/python/auth/customized_auth_client.py#L34
                2. create channel https://github.com/grpc/grpc/blob/master/examples/python/auth/customized_auth_client.py#L56C5-L56C26
                    - wrap gateway as call credentials
                    - create tls credential
                    - combine them together
                    - secure channel using combined credentials
        - Async
            - server
                - implement grpc.aio.ServerInterceptor instead https://github.com/grpc/grpc/blob/master/examples/python/auth/async_customized_auth_server.py#L35
                - server is created using grpc.aio.server https://github.com/grpc/grpc/blob/master/examples/python/auth/async_customized_auth_server.py#L70C14-L70C29
            - client
                - channel is created using grpc.aio.secure_channel method https://github.com/grpc/grpc/blob/master/examples/python/auth/async_customized_auth_client.py#L72
- [x] https://grpc.io/docs/guides/benchmarking/
    - Continuous performance benchmarking is part of the gRPC development workflow.
    - Multi-language performance tests run every few hours against the "master" branch, and results are reported to a dashboard for visualization. https://grafana-dot-grpc-testing.appspot.com/
    - The benchmarks measure several workload scenarios; among them:
        - Contentionless latency - median and tail latencies when a single client sends one message at a time using StreamingCall.
        - QPS (Queries Per Second) - throughput measured as messages per second under load: e.g. 2 clients, total of 64 channels, each having 100 outstanding messages, using StreamingCall.
        - Scalability (for some languages) - number of messages per second per server core (i.e. how performance scales with server cores) under load.
- [x] https://grpc.io/docs/guides/cancellation/
    - when a client no longer cares about the result of an RPC, it can cancel the call to signal that interest ended. 
    - a deadline expiring or I/O errors - also trigger cancellation. 
    - The gRPC library does *not* automatically interrupt the handler. 
        - For certain languages (e.g. Java, Go, C++), gRPC automatically cancels outgoing RPCs when an incoming RPC is cancelled.
        - In other languages (e.g. Python) the server handler author is responsible for coordinating cancellation and cleaning up outgoing work.
    - For long-running RPCs/handlers, server code must explicitly observe cancellation.
    - When an RPC is cancelled, the server should stop any ongoing computation, terminate its side of the stream and propagate cancellation.
    - On the client side, cancellation is done by calling a method on the call object (or, in some languages, on an associated "context" object). 
        - reason is **not** communicated to the server.  
- [x] https://github.com/grpc/grpc/tree/master/examples/python/cancellation
    - client (unary/streaming) cancel will be triggered when the user interrupts the process with ctrl-c
        - store future/generator in a variable
            - unary - https://github.com/grpc/grpc/blob/master/examples/python/cancellation/client.py#L37
            - streaming - https://github.com/grpc/grpc/blob/master/examples/python/cancellation/client.py#L58
        - call cancel
            - unary - https://github.com/grpc/grpc/blob/master/examples/python/cancellation/client.py#L45
            - streaming - https://github.com/grpc/grpc/blob/master/examples/python/cancellation/client.py#L68
        - call sys.exit(0) to terminate the process
    - server
        - for a cancel triggered on client side
            - create threading event https://github.com/grpc/grpc/blob/master/examples/python/cancellation/server.py#L43
            - add callback to the context https://github.com/grpc/grpc/blob/master/examples/python/cancellation/server.py#L49
                - set RPC as cancelled https://github.com/grpc/grpc/blob/master/examples/python/cancellation/server.py#L47
            - check if RPC was cancelled https://github.com/grpc/grpc/blob/master/examples/python/cancellation/search.py#L133
        - to trigger cancel on server side
            - call .cancel on the context https://github.com/grpc/grpc/blob/master/examples/python/cancellation/server.py#L62
        - consider returning a more specific error using the [grpcio-status](https://pypi.org/project/grpcio-status/) package
- [x] https://grpc.io/docs/guides/compression/
    - Compression can be enabled or disabled at the level of a call or a message. 
        - In some languages, you can also control compression at the channel level.
    - gRPC allows *asymmetrically compressed communication* - a response may be compressed differently with the request, or not compressed at all. 
    - If a client sends a message compressed by an algorithm the server does not support - the server will respond with an `UNIMPLEMENTED` error. 
        - In that case, the server’s response will include a `grpc-accept-encoding` header listing the compression algorithms it supports. 
    - If the client used an algorithm listed in that `grpc-accept-encoding` header but still gets `UNIMPLEMENTED`, the error is not considered a compression-related issue. 
    - A peer may choose not to advertise all supported encodings - but if it receives a message compressed with a supported but undisclosed encoding, it will still accept it and include that encoding in its response header. 
    - If a server tries to compress a message using an algorithm it knows the client does not support (based on the last `grpc-accept-encoding` from the client), it will send the message uncompressed. 
    - It is possible to explicitly disable compression for a given message; in that case the message will be sent uncompressed.
        - Disabling compression may be important to prevent BEAST and CRIME attacks.
            - BEAST attack - Browser Exploit Against SSL/TLS - is a cryptographic exploit that targets vulnerabilities in TLS 1.0’s block-cipher implementation to decrypt secure HTTPS cookies by manipulating and observing encrypted traffic.
            - CRIME attack - exploits TLS-level or SPDY-level compression to recover secret data (such as session cookies) by observing how compression ratios change in encrypted traffic.

- [x] https://github.com/grpc/grpc/tree/master/examples/python/compression
    - There are 3 compression levels available in Python gRPC.
        - `grpc.Compression.NoCompression` - no compression (this is the default).
        - `grpc.Compression.Deflate` - uses the “Deflate” algorithm.
        - `grpc.Compression.Gzip` - uses Gzip algorithm.
    - Client
        - at channel level https://github.com/grpc/grpc/blob/master/examples/python/compression/client.py#L40
        - per-RPC https://github.com/grpc/grpc/blob/master/examples/python/compression/client.py#L46
    - Server
        - at server level https://github.com/grpc/grpc/blob/master/examples/python/compression/server.py#L67
        - per-RPC https://github.com/grpc/grpc/blob/master/examples/python/compression/server.py#L60
